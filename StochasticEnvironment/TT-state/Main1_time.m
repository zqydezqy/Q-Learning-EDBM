%主函数
%========================初始化=======================%
clear;close all;
init;%初始化，包括初始化线路模型，计算初始速度曲线等
positions=gradient(:,1)';
sections=positions.*1000;
sections=[sections,s_brake];
sections(1)=s_acc;%可以分配能量的区段
figure();
subplot(3,1,1);
plot(S,V);axis([0,1400,0,18]);title('Original Solution')


%% ==========================Q学习方法1：以时间作为状态:训练参数设置========================
%=======奖励：进入终点状态奖励为0，其他为-1=======
n_actions=length(sections)-3;%动作空间：所有可以分配能量的区段,不要在最后两个区段分能量
StateSpace_Time;
% QEnergy=zeros(n_states,n_actions);
QEnergy=ones(n_states,n_actions)*500;
dE=0.5;%单位：千瓦时
% dE=0.1;%单位：千瓦时
N_Episodes=200000;
% N_Episodes=11;
% N_Episodes=10000;
% N_Episodes=100000;%100000个片段时能达到和普通方法等同的效果
alpha=0.1;
gamma=0.9;
% alpha=0.5;
% gamma=0.8;

epsilon = 0.1;
% eps=0.05:0.05:0.95;
start_state=torg-torg+1;
% end_state=torg-topt1+1;
end_state=time2state(topt,torg,dt);
delta=100;%训练前后值函数最大误差，衡量训练是否可以结束
ei=1;%片段数
optimaltimes=0;
Result_TotalReward=[];
Result_Steps=[];
%% 训练过程
tic;
% for ei=1:N_Episodes
while optimaltimes<5
    st=start_state;
    Vnew=V(1,:);
    Anew=Acceleration(1,:);
    E_dis_new=zeros(1,length(sections));
    Q1=QEnergy(:,:);%旧的值函数表，用来计算两次值函数的误差
    tnew=torg;%原来的时间
    Davis=StoDavis(Davis0,0);%本片段的戴维斯参数
    ttt=0;
    discount_reward=0;
    while st<end_state &&ttt<50
        ttt=ttt+1;
        at=eps_greedy(st,QEnergy,epsilon,n_actions);
        %采取动作：即分配能量
        %[Vnew,Anew]=distribute_energy_for_section2(dE,at,sections,Anew,Vnew,S,ds,v_forward,acc_forward,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
        E_dis_new(at)=E_dis_new(at)+1;
        [Vnew,Anew,Fnew]=energy2speedprofile2(dE,E_dis_new,sections,Acceleration,V,S,...
    ds,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
        told=tnew;
        [Tnew,tnew]=caculate_time(Vnew,S,ds);
        %st1=torg-fix(tnew)+1;%得到新的状态
        st1=time2state(tnew,torg,dt);
%         if(st1<=0)%出现时间倒退的现象;
%             QEnergy(st,at)=QEnergy(st,at)-2;
%             st1=st;%保持状态不变
%         else
         reward=told-tnew;%以时间做奖励
         discount_reward=discount_reward+reward*(gamma^(ttt-1));
          if(st1<end_state)
            value=max(QEnergy(st1,:));
         %QEnergy(st,at)=QEnergy(st,at)+alpha*(-1+gamma*value-QEnergy(st,at));
          QEnergy(st,at)=QEnergy(st,at)+alpha*(reward+gamma*value-QEnergy(st,at));
           else
            st1=end_state;
         %QEnergy(st,at)=QEnergy(st,at)+alpha*(0-QEnergy(st,at));
        QEnergy(st,at)=QEnergy(st,at)+alpha*(reward+gamma*value-QEnergy(st,at));
%             st1=end_state;
          end
        st=st1;
    end%结束一个片段    
%     delta=max(max(abs(Q1-QEnergy)));
    Result_TotalReward=[Result_TotalReward,discount_reward];
    fprintf("第%d个片段训练结束\n",ei);
    tnew;
    ei=ei+1;
    %利用习得的策略分配能量得到曲线
    ttt=0;
    st=start_state;
    dt=0.1;
    Voptq=V(1,:);
    Aoptq=Acceleration(1,:);
    E_dis_optq=zeros(1,length(sections));
    while st~=end_state&&ttt<30
        ttt=ttt+1;
        at=eps_greedy(st,QEnergy,0,n_actions);
        %[Vopt,Aopt]=distribute_energy_for_section2(dE,at,sections,Aopt,Vopt,S,ds,v_forward,acc_forward,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
        E_dis_optq(at)=E_dis_optq(at)+1;
        [Voptq,Aoptq,Foptq]=energy2speedprofile2(dE,E_dis_optq,sections,Acceleration,V,S,...
            ds,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
        [Toptq,toptq]=caculate_time(Voptq,S,ds);
        %st1=torg-fix(topt)+1;%得到新的状态
        st1=time2state(toptq,torg,dt);
        if(st1>end_state)
            st=end_state;
        else
            st=st1;
        end
    end
    [Toptq,toptq]=caculate_time(Voptq,S,ds);
    [Eoptq,eoptq]=caculate_energy(Foptq,S,ds);
    Result_Steps=[Result_Steps,ttt];
%     if(toptq< 94.95 && eoptq<13.13)
    if(E_dis_optq(1)>=14)
        optimaltimes=optimaltimes+1;
    else
        optimaltimes=0;
    end
end%结束最外层for循环，结束所有片段训练.
toc;
%%
%利用习得的策略分配能量得到曲线
st=start_state;
dt=0.1;
Voptq=V(1,:);
Aoptq=Acceleration(1,:);
E_dis_optq=zeros(1,length(sections));
Davis=StoDavis(Davis0,0);%本片段的戴维斯参数
while st~=end_state
    at=eps_greedy(st,QEnergy,0,n_actions);
    %[Vopt,Aopt]=distribute_energy_for_section2(dE,at,sections,Aopt,Vopt,S,ds,v_forward,acc_forward,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
    E_dis_optq(at)=E_dis_optq(at)+1;
    [Voptq,Aoptq,Foptq]=energy2speedprofile2(dE,E_dis_optq,sections,Acceleration,V,S,...
    ds,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
    [Toptq,toptq]=caculate_time(Voptq,S,ds);
    %st1=torg-fix(topt)+1;%得到新的状态
    st1=time2state(toptq,torg,dt);
    if(st1>end_state)
        st=end_state;
    else
        st=st1;
    end
end
[Toptq,toptq]=caculate_time(Voptq,S,ds);
[Eoptq,eoptq]=caculate_energy(Foptq,S,ds);
fprintf("用Qlearning方法优化后总耗时为：%f秒\n",toptq)
fprintf("用Qlearning方法优化后总的牵引能耗为：%f千瓦时\n\n",eoptq)
%figure(2);
subplot(3,1,2);
plot(S,Voptq);title('Optimal Solution with Q-Learning Approach')
%% 普通方法
t_target=topt;
Vopt2=V(1,:);
Aopt2=Acceleration(1,:);
Topt2=T0(1,:);
Eopt2=E0(1,:);%以上四项都是最优化的项
Fopt2=Fraction(1,:);
topt2=t0;
eopt2=e0; 
count=1;%计数器，计现在是第几次更新
E_dis_opt=zeros(1,length(sections));%记录已经分配出去的能量
Davis=StoDavis(Davis0,0);%本片段的戴维斯参数
while topt2>t_target    
    etratemax=0;%能量和时间的比值，谁大证明谁的效果好，更应该分配给这个区段 
    Vtemp=Vopt2(1,:);
    Atemp=Aopt2(1,:);
    Ttemp=Topt2(1,:);
    Etemp=Eopt2(1,:);%以上四项是中间变量
    Ftemp=Fopt2(1,:);
    E_dis_temp=E_dis_opt(1,:);
    fprintf("第%d次分配能量\n",count)
    for i=1:length(sections)%穷举每一个区段（按坡度划分），看谁的节约时间效果好
    [Vnew,Anew,Fnew,E_dis_new]=distribute_energy_for_section5(dE,E_dis_opt,i,...
        sections,Aopt2,Vopt2,S,...
     ds,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
    [Tnew,tnew]=caculate_time(Vnew,S,ds);
    [Enew,enew]=caculate_energy(Fnew,S,ds);
    dt1=abs(tnew-topt2);
    if dt1>etratemax
        etratemax=dt1;
        aopt=i;
        Vtemp=Vnew(1,:);
        Atemp=Anew(1,:);
        Ttemp=Tnew(1,:);
        Etemp=Enew(1,:);
        Ftemp=Fnew(1,:);
        E_dis_temp=E_dis_new(1,:);
    end
    end%结束给每个区段分能量的for循环
    Vopt2=Vtemp(1,:);
    Aopt2=Atemp(1,:);
    Fopt2=Ftemp(1,:);
    E_dis_opt=E_dis_temp(1,:);
    [Topt2,topt2]=caculate_time(Vopt2,S,ds);
    [Eopt2,eopt2]=caculate_energy(Fopt2,S,ds);
    fprintf("第%d次分配能量给第%d个区间后，功耗变为%f，耗时变为%f\n",count,aopt,eopt2,topt2);
    fprintf("\n");
    count=count+1;
end%结束大循环
[Topt2,topt2]=caculate_time(Vopt2,S,ds);
[Eopt2,eopt2]=caculate_energy(Fopt2,S,ds);
fprintf("普通方法优化后总耗时为：%f秒\n",topt2)
fprintf("普通方法优化后总的牵引能耗为：%f千瓦时\n",eopt2)
subplot(3,1,3);
plot(S,Vopt2);title('Optimal Solution with EDBM')
%% ==========================测试1：分配一次能量=========================================
% dE=2;  
% index=2;
% E_distributed=zeros(1,length(sections));
% [Vnew,Anew,Fnew,E_distributed]=distribute_energy_for_section4(dE,E_distributed,index,sections,Acceleration,V,S,...
%     ds,index_acc,index_brake,v_backward,acc_backward,Davis,acc_grad,vc,Mass,MaxDeccel);
% [T1,t1]=caculate_time(Vnew,S,ds);
% [E1,e1]=caculate_energy(Fnew,S,ds);
% fprintf("在第%d个区间分配能量后：\n",index);
% fprintf("初始总耗时为：%f秒\n",t1)
% fprintf("初始总的牵引能耗为：%f千瓦时\n",e1)
% figure(2);
% plot(S,Vnew);title('分配能量后的运行曲线')

